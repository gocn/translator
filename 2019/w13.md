# 在 Go 程序中使用 context 提供的取消功能

- 原文地址:https://www.sohamkamani.com/blog/golang/2018-06-17-golang-using-context-cancellation/
- 原文作者: [Soham Kamani](https://www.packtpub.com/books/info/authors/soham-kamani)
- 译文出处: https://www.sohamkamani.com
- 本文永久链接: https://github.com/gocn/translator/blob/master/2019/w13.md
- 译者: [yufeng0924](https://github.com/yufeng0924)
- 校对者:[xuelike](https://github.com/xuelike)

很多使用 Go 的用户将会在工作中碰到 `context`这个库。 使用`context`最多的场景是在处理下游数据，例如发起一个 HTTP 的请求或者从 DataBase 获取数据，又或者使用 `goroutine` 执行异步操作。 `context` 最常见的用途是传递可供所有下游操作使用的通用数据。然而，或许很少人知道 ， `context` 能够取消或者终止正在运行中的操作这一最有用的特性。 

本文中我们会介绍如何使用 `context` 中取消功能， 我们会通过一些流程图和简单的代码示例， 看如何让我们的应用(程序)更快并且更稳定。
## 我们为什么需要一个取消功能
简而言之，我们需要防止我们的系统做一些不必要的工作。  

让我们来考虑这样一个场景，一个 HTTP 的 `web` 服务去请求数据库并且返回查询结果给用户(客户端)。 如下图所示:

![](https://www.sohamkamani.com/client-diagram-199c2b8faf7663c9b7e83de127012a6c.svg )

如果这个请求是正常执行的，整个请求的生命周期如下图所示:

![](https://www.sohamkamani.com/timing-ideal-ff6e4d831668b9da81c1c214224e4521.svg)

但是如果客户端突然中止了请求会发生什么样的情况? 这种情况是容易出现的， 例如:在数据请求过程中用户突然关闭了浏览器. 对应的后端响应如果没有取消， 那么服务器和数据库将继续一些列的操作， 即使有结果返回其实也是一个资源上的浪费.

![](https://www.sohamkamani.com/timing-without-cancel-4955e194034f42b5edd7632f1461c124.svg)

理想状态下，我们是希望在客户端发生中断之后后续的所有资源都将取消.如下图所示，所有的节点上的工作将会全部取消(在这个例子中，以``HTTP`` 请求为例)

![](https://www.sohamkamani.com/timing-with-cancel-2af484f735aab3022ea8d7a9a9c1b675.svg)

## 下面我们进入正文， 在 Go 中如何用 context 的取消功能

现在我们已经知道为什么我们的程序需要取消功能， 下面让我们看下如何用 ``Go`` 实现该功能。 因为这个取消事件与正在执行的事务或操作高度相关， 所以很自然， 它与   ``context``捆绑在一起。

这里有 2 个地方或许你需要去实现来达到取消的效果。
- 监听这个取消的事件。
- 发出取消的命令。

## 监听到取消的事件

`context` 类型提供了一个 `Done()` 的方法，该方法返回每次 `context` 接收取消事件时接收空 `struct{}` 类型的 `channel`。 监听一个取消事件就是调用 `ctx->Done()` 这么简单。 

例如， 让我们考虑需要两秒钟来处理事件的 HTTP 服务器。 如果请求在那之前被取消， 我们想立即返回

代码如下:
```go
func main() {
	// Create an HTTP server that listens on port 8000
	http.ListenAndServe(":8000", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()
		// This prints to STDOUT to show that processing has started
		fmt.Fprint(os.Stdout, "processing request\n")
		// We use `select` to execute a peice of code depending on which
		// channel receives a message first
		select {
		case <-time.After(2 * time.Second):
			// If we receive a message after 2 seconds
			// that means the request has been processed
			// We then write this as the response
			w.Write([]byte("request processed"))
		case <-ctx.Done():
			// If the request gets cancelled, log it
			// to STDERR
			fmt.Fprint(os.Stderr, "request cancelled\n")
		}
	}))
}
```
所有代码的示例可以在这里找到 https://github.com/sohamkamani/blog-example-go-context-cancellation  

现在我们可以启动这个服务， 并且在浏览器访问 localhost:8000， 然后在 2 秒以内进行关闭浏览器的操作， 我们会在终端看到 "request cancelled" 打印的结果。

## 发起一个取消的命令

如果你正在操作某些资源， 需要发起取消命令的时候， 你可以通过 `context` 来发起这个取消操作。 我们可以使用 `context` 包中的 `WithCancel` 函数， 它会返回一个 `context` 对象和一个函数， 该类型中有一个函数， 这个函数不接受任何参数， 也不返回任何内容， 当您要取消 `context` 时， 将调用此函数。

让我们考虑这样一个应用场景， 该操作需要 2 个「依赖」关系(类似于 mysql 的事务操作)其中一个失败了。 另外一个操作其实是没有必须继续的。 如果我们知道其中一个失败了。 我们是希望把之前的其他操作进行一个取消的。
让我们看下具体实现。



代码如下:
```go
func operation1(ctx context.Context) error {
	// Let's assume that this operation failed for some reason
	// We use time.Sleep to simulate a resource intensive operation
	time.Sleep(100 * time.Millisecond)
	return errors.New("failed")
}

func operation2(ctx context.Context) {
	// We use a similar pattern to the HTTP server
	// that we saw in the earlier example
	select {
	case <-time.After(500 * time.Millisecond):
		fmt.Println("done")
	case <-ctx.Done():
		fmt.Println("halted operation2")
	}
}

func main() {
	// Create a new context
	ctx := context.Background()
	// Create a new context, with its cancellation function
	// from the original context
	ctx, cancel := context.WithCancel(ctx)

	// Run two operations: one in a different go routine
	go func() {
		err := operation1(ctx)
		// If this operation returns an error
		// cancel all operations using this context
		if err != nil {
			cancel()
		}
	}()

	// Run operation2 with the same context we use for operation1
	operation2(ctx)
}
```

## 定时取消任务

任何需要在请求的最长持续时间内维护 SLA ( service level agreement ) 的应用程序都应使用基于定时的取消。 下面这段 API 和前面的 API 是一样的, 只是加了一些额外的代码
```go
// The context will be cancelled after 3 seconds
// If it needs to be cancelled earlier, the `cancel` function can
// be used, like before
ctx, cancel := context.WithTimeout(ctx, 3*time.Second)

// The context will be cancelled on 2009-11-10 23:00:00
ctx, cancel := context.WithDeadline(ctx, time.Date(2009, time.November, 10, 23, 0, 0, 0, time.UTC))
```
例如我们的服务中有依赖于第三方的请求， 如果第三方的服务不稳定或者影响的时间过长， 我们可能需要提前去取消这个依赖请求。

```go
func main() {
	// Create a new context
	// With a deadline of 100 milliseconds
	ctx := context.Background()
	ctx, _ = context.WithTimeout(ctx, 100*time.Millisecond)

	// Make a request, that will call the google homepage
	req, _ := http.NewRequest(http.MethodGet, "http://google.com", nil)
	// Associate the cancellable context we just created to the request
	req = req.WithContext(ctx)

	// Create a new HTTP client and execute the request
	client := &http.Client{}
	res, err := client.Do(req)
	// If the request failed, log to STDOUT
	if err != nil {
		fmt.Println("Request failed:", err)
		return
	}
	// Print the statuscode if the request succeeds
	fmt.Println("Response received, status code:", res.StatusCode)
}
```
这个服务会依赖于 Google 的首页相应时间。 多次请求你回收到不同的返回结果。 (国内用户可以修改任意可以访问的地址)
- Response received， status code: 200

或者是

- Request failed: Get http://google.com: context deadline exceeded

你可以调整 `timeout` 的设置来达到上面 2 个情况的效果。

## 理解该功能和一些建议忠告

尽管取消命令是 context 一个通用的功能， 但是有一些情况你需要特别注意在你开始在代码里加入或者已经使用了该功能。

- 取消操作在 context 中只可以使用一次。如果有很多的失败的信息在一个操作中， 你希望通过 context 取消命令去广播到每一个操作， 用 context 不是一个最好的选择。在使用之前你应该很清楚的知道你要取消的是什么操作，而不是简单地告知下游数据这里有一个错误出现了。  

- 第二个情况是你应该把相通的上下文传递给所有使用该上下文的函数和 goroutine 。 当使用 ``WithTimeout`` 和 ``WithCancel`` 去操作一个已经被取消的 context 的包的时候会发生很多可能性， 这个是需要进行避免的。
